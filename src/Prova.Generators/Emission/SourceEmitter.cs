using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Prova.Generators.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Prova.Generators.Emission
{
    internal static class SourceEmitter
    {
        public static void Execute(SourceProductionContext context, ImmutableArray<TestMethodModel?> methods)
        {
            if (methods.IsDefaultOrEmpty) return;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using System.Threading;"); // For Interlocked
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using Prova;");
            sb.AppendLine("using Prova.Reporters;");
            sb.AppendLine();
            sb.AppendLine("namespace Prova.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    public static class TestRunnerExecutor");
            sb.AppendLine("    {");
            sb.AppendLine("        public static async global::System.Threading.Tasks.Task RunAllAsync(string[]? args = null)");
            sb.AppendLine("        {");
            sb.AppendLine("            var reporter = new ConsoleReporter();");
            sb.AppendLine("            int passed = 0, failed = 0, skipped = 0;");
            sb.AppendLine("            var sw = global::System.Diagnostics.Stopwatch.StartNew();");
            sb.AppendLine();
            sb.AppendLine("            // Parse Filters");
            sb.AppendLine("            var filters = new global::System.Collections.Generic.List<global::System.Collections.Generic.KeyValuePair<string, string>>();");
            sb.AppendLine("            if (args != null)");
            sb.AppendLine("            {");
            sb.AppendLine("                for (int i = 0; i < args.Length; i++)");
            sb.AppendLine("                {");
            sb.AppendLine("                    if (args[i] == \"--filter\" && i + 1 < args.Length)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        var parts = args[i+1].Split('=');");
            sb.AppendLine("                        if (parts.Length == 2) filters.Add(new global::System.Collections.Generic.KeyValuePair<string, string>(parts[0], parts[1]));");
            sb.AppendLine("                    }");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine();
            
            sb.AppendLine("            var classTasks = new global::System.Collections.Generic.List<global::System.Threading.Tasks.Task>();");

            // Logic for [Focus]
            var allMethods = methods.Where(m => m != null).ToList();
            var hasFocus = allMethods.Any(m => m!.IsFocused);
            var activeMethods = hasFocus 
                ? allMethods.Where(m => m!.IsFocused).ToList() 
                : allMethods;
            
            if (hasFocus)
            {
                 sb.AppendLine("            // [Focus] Mode Active: Only running focused tests.");
            }

            var groupedMethods = activeMethods.GroupBy(m => m!.ClassName);

            foreach (var group in groupedMethods)
            {
                var className = group.Key;
                var classFixtures = group.First()!.FixtureTypes;
                
                // START Parallel Task for Class
                sb.AppendLine();
                sb.AppendLine($"            classTasks.Add(global::System.Threading.Tasks.Task.Run(async () =>");
                sb.AppendLine($"            {{");
                sb.AppendLine($"                // Class: {className}");
                
                // Initialize Fixtures
                foreach (var fixtureType in classFixtures)
                {
                    var varName = $"fixture_{fixtureType.Replace(".", "_")}";
                    sb.AppendLine($"                var {varName} = new {fixtureType}();");
                    sb.AppendLine($"                if ({varName} is IAsyncLifetime al_init_{varName}) await al_init_{varName}.InitializeAsync();");
                }

                foreach (var method in group)
                {
                     if (method == null) continue;

                     // Check Skip
                     if (!string.IsNullOrEmpty(method.SkipReason))
                     {
                         sb.AppendLine($"                reporter.OnTestSkipped(\"{method.ClassName}.{method.MethodName}\", \"{method.SkipReason}\");");
                         sb.AppendLine($"                global::System.Threading.Interlocked.Increment(ref skipped);");
                         continue;
                     }

                     // Check Traits (Filter)
                     if (method.Traits.Count > 0)
                     {
                         var attributesString = string.Join(", ", method.Traits.Select(t => $"new global::System.Collections.Generic.KeyValuePair<string,string>(\"{t.Key}\", \"{t.Value}\")"));
                         sb.AppendLine($"                var traits_{method.MethodName} = new global::System.Collections.Generic.List<global::System.Collections.Generic.KeyValuePair<string,string>> {{ {attributesString} }};");
                         sb.AppendLine($"                if (filters.Any() && !filters.All(f => traits_{method.MethodName}.Contains(f)))");
                         sb.AppendLine("                {");
                         sb.AppendLine("                    // Filtered out");
                         sb.AppendLine("                }");
                         sb.AppendLine("                else");
                         sb.AppendLine("                {");
                     }
                     else
                     {
                         sb.AppendLine($"                if (filters.Any()) {{ /* Filter active but no traits on method -> skip */ }} else {{");
                     }

                     if (method.IsTheory)
                    {
                        int theoryIndex = 0;
                        
                        // InlineData
                        if (method.TestData.Count > 0)
                        {
                            foreach (var args in method.TestData)
                            {
                                var argsString = string.Join(", ", args);
                                GenerateTestCall(sb, method, argsString, $"[{theoryIndex++}]");
                            }
                        }

                        // MemberData
                        if (method.MemberData.Count > 0)
                        {
                            foreach (var md in method.MemberData)
                            {
                                var targetType = md.MemberType ?? method.ClassName; 
                                var invoke = $"{targetType}.{md.MemberName}";
                                
                                string access;
                                if (md.Parameters.Length > 0)
                                {
                                     access = $"{invoke}({string.Join(", ", md.Parameters)})";
                                }
                                else
                                {
                                     access = md.IsMethod ? $"{invoke}()" : $"{invoke}"; 
                                }

                                sb.AppendLine($"                // MemberData: {md.MemberName}");
                                sb.AppendLine($"                foreach (var dataRow in {access})");
                                sb.AppendLine("                {");
                                sb.AppendLine("                    {");
                                 // Construct arguments list with casts
                                 var castArgs = new List<string>();
                                 for(int i = 0; i < method.ParameterTypes.Count; i++)
                                 {
                                     string typeName = method.ParameterTypes[i];
                                     castArgs.Add($"({typeName})dataRow[{i}]");
                                 }
                                 string dynamicArgs = string.Join(", ", castArgs);
                                 
                                 GenerateTestCall(sb, method, dynamicArgs, $"[_dynamic_{theoryIndex++}]");

                                sb.AppendLine("                    }");
                                sb.AppendLine("                }");
                            }
                        }
                    }
                    else
                    {
                        GenerateTestCall(sb, method, "", "");
                    }

                    if (method.Traits.Count > 0 || true) // Close the filter block
                    {
                         sb.AppendLine("                }");
                    }
                }

                // Dispose Fixtures
                foreach (var fixtureType in classFixtures)
                {
                    var varName = $"fixture_{fixtureType.Replace(".", "_")}";
                    sb.AppendLine($"                if ({varName} is IAsyncLifetime al_{varName}) await al_{varName}.DisposeAsync();");
                    sb.AppendLine($"                else if ({varName} is global::System.IDisposable d_{varName}) d_{varName}.Dispose();");
                }
                
                sb.AppendLine($"            }}));"); // END Parallel Task
            }

            sb.AppendLine("            await global::System.Threading.Tasks.Task.WhenAll(classTasks);");
            sb.AppendLine("            sw.Stop();");
            sb.AppendLine("            reporter.OnComplete(passed, failed, skipped, sw.Elapsed);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        private static async global::System.Threading.Tasks.Task<bool> RunTestSafe(global::System.Func<global::System.Threading.Tasks.Task> test, string name, ITestReporter reporter, string? output, string? description = null, int retryCount = 0)");
            sb.AppendLine("        {");
            sb.AppendLine("             reporter.OnTestStarting(name, description);");
            sb.AppendLine("             ");
            sb.AppendLine("             // Retry Loop");
            sb.AppendLine("             int attempt = 0;");
            sb.AppendLine("             while (true)");
            sb.AppendLine("             {");
            sb.AppendLine("                 try {");
            sb.AppendLine("                     await test();");
            sb.AppendLine("                     reporter.OnTestSuccess(name, output ?? \"\");");
            sb.AppendLine("                     return true;");
            sb.AppendLine("                 } catch (global::System.Exception ex) {");
            sb.AppendLine("                     attempt++;");
            sb.AppendLine("                     if (attempt <= retryCount)");
            sb.AppendLine("                     {");
            sb.AppendLine("                         // Optional: Report retry?");
            sb.AppendLine("                         // reporter.OnTestRetry(name, attempt);");
            sb.AppendLine("                         // For now, silent retry unless final failure.");
            sb.AppendLine("                         continue;");
            sb.AppendLine("                     }");
            sb.AppendLine("                     ");
            sb.AppendLine("                     reporter.OnTestFailure(name, ex, output ?? \"\");");
            sb.AppendLine("                     return false;");
            sb.AppendLine("                 }");
            sb.AppendLine("             }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            context.AddSource("TestRunnerExecutor.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static void GenerateTestCall(StringBuilder sb, TestMethodModel method, string args, string suffix)
        {
             sb.AppendLine($"                    // Test: {method.ClassName}.{method.MethodName}{suffix}");
             sb.AppendLine("                    {"); 
             
             if (method.UsesOutputHelper)
             {
                 sb.AppendLine($"                        var outputHelper = new TestOutputHelper();");
             }

             sb.AppendLine($"                        if (await RunTestSafe(async () => {{");
             
             if (!method.IsStatic)
             {
                 string constructorArgs = string.Join(", ", method.Dependencies);
                 sb.AppendLine($"                            var instance = new {method.ClassName}({constructorArgs});");
                 
                 if (method.ImplementsAsyncLifetime)
                 {
                     sb.AppendLine($"                            if (instance is IAsyncLifetime asyncLifeInit) await asyncLifeInit.InitializeAsync();");
                 }
             }

             sb.AppendLine("                            try {");
             
                string target = method.IsStatic ? method.ClassName : "instance";
                if (method.IsAsync)
                    sb.AppendLine($"                                await {target}.{method.MethodName}({args});");
                else
                    sb.AppendLine($"                                {target}.{method.MethodName}({args});");

                // Nordic Suite: Smart Verify üõ°Ô∏è
                // Automatically verify all Skugga mocks
                if (!method.IsStatic && method.MockFields.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine("                                // Nordic Suite: Smart Verify üõ°Ô∏è");
                    sb.AppendLine("                                // Automatically verify all Skugga mocks");
                    sb.AppendLine("                                if (true) {");
                    foreach (var mockName in method.MockFields)
                    {
                        sb.AppendLine($"                                    instance.{mockName}.VerifyAll();");
                    }
                    sb.AppendLine("                                }");
                }

             sb.AppendLine("                            } finally {");
             if (!method.IsStatic)
             {
                 if (method.ImplementsAsyncLifetime)
                 {
                     sb.AppendLine($"                                if (instance is IAsyncLifetime asyncLifeDisp) await asyncLifeDisp.DisposeAsync();");
                 }
                 sb.AppendLine($"                                if (instance is global::System.IDisposable d) d.Dispose();");
             }
             sb.AppendLine("                            }");
             
             string outputArg = method.UsesOutputHelper ? "outputHelper.Output" : "null";
             string descArg = method.Description == null ? "null" : $"\"{method.Description}\"";
             sb.AppendLine($"                        }}, \"{method.ClassName}.{method.MethodName}{suffix}\", reporter, {outputArg}, {descArg}, {method.RetryCount}))");
             
             sb.AppendLine($"                            global::System.Threading.Interlocked.Increment(ref passed);");
             sb.AppendLine($"                        else");
             sb.AppendLine($"                            global::System.Threading.Interlocked.Increment(ref failed);");
             sb.AppendLine("                    }"); 
             sb.AppendLine();
        }
    }
}
