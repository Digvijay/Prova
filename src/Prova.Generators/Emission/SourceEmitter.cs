using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Prova.Generators.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Prova.Generators.Emission
{
    internal static class SourceEmitter
    {
        public static void Execute(SourceProductionContext context, ImmutableArray<TestMethodModel?> methods)
        {
            if (methods.IsDefaultOrEmpty) return;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using Prova;");
            sb.AppendLine("using Prova.Reporters;");
            sb.AppendLine("using Microsoft.Testing.Extensions;");
            sb.AppendLine();
            sb.AppendLine("namespace Prova.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Executor for running tests.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class TestRunnerExecutor");
            sb.AppendLine("    {");
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Runs all tests.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <param name=\"args\">The command line arguments.</param>");
            sb.AppendLine("        public static async global::System.Threading.Tasks.Task RunAllAsync(string[]? args = null)");
            sb.AppendLine("        {");
            sb.AppendLine("            args ??= global::System.Array.Empty<string>();");
            sb.AppendLine("            bool isMtp = args.Any(a => a == \"--list-tests\" || a == \"--server\" || a.StartsWith(\"--client-port\") || a == \"--report-trx\" || a == \"--coverage\" || a == \"--help\" || a == \"-?\" || a == \"-h\");");
            sb.AppendLine("            bool isSimple = args.Contains(\"--simple\");");
            sb.AppendLine();
            sb.AppendLine("            if (isMtp && !isSimple)");
            sb.AppendLine("            {");
            sb.AppendLine("                await RunMtpAsync(args);");
            sb.AppendLine("            }");
            sb.AppendLine("            else");
            sb.AppendLine("            {");
            sb.AppendLine("                await RunSimpleAsync(args);");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        private static async global::System.Threading.Tasks.Task RunMtpAsync(string[] args)");
            sb.AppendLine("        {");
            sb.AppendLine("            var builder = await global::Microsoft.Testing.Platform.Builder.TestApplication.CreateBuilderAsync(args);");
            sb.AppendLine("            builder.AddTrxReportProvider();");
            sb.AppendLine("            builder.AddCodeCoverageProvider();");
            sb.AppendLine("            builder.RegisterTestFramework(");
            sb.AppendLine("                _ => new ProvaCapabilities(),");
            sb.AppendLine("                (cap, _) => new HybridMtpAdapter(GetTests(), cap));");
            sb.AppendLine("            using var app = await builder.BuildAsync();");
            sb.AppendLine("            await app.RunAsync();");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        private static async global::System.Threading.Tasks.Task RunSimpleAsync(string[] args)");
            sb.AppendLine("        {");
            sb.AppendLine("            var reporter = new ConsoleReporter();");
            sb.AppendLine("            int passed = 0, failed = 0, skipped = 0;");
            sb.AppendLine("            var sw = global::System.Diagnostics.Stopwatch.StartNew();");
            sb.AppendLine();
            sb.AppendLine("            var filters = new global::System.Collections.Generic.List<global::System.Collections.Generic.KeyValuePair<string, string>>();");
            sb.AppendLine("            for (int i = 0; i < args.Length; i++)");
            sb.AppendLine("            {");
            sb.AppendLine("                if (args[i] == \"--filter\" && i + 1 < args.Length)");
            sb.AppendLine("                {");
            sb.AppendLine("                    var parts = args[i+1].Split('=');");
            sb.AppendLine("                    if (parts.Length == 2) filters.Add(new global::System.Collections.Generic.KeyValuePair<string, string>(parts[0], parts[1]));");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            var tests = GetTests();");
            sb.AppendLine("            var hasFocus = tests.Any(t => t.Traits.Any(tr => tr.Key == \"Focus\"));");
            sb.AppendLine("            var activeTests = hasFocus ");
            sb.AppendLine("                ? tests.Where(t => t.Traits.Any(tr => tr.Key == \"Focus\")).ToList() ");
            sb.AppendLine("                : tests.ToList();");
            sb.AppendLine();
            sb.AppendLine("            if (hasFocus)");
            sb.AppendLine("            {");
            sb.AppendLine("                 global::System.Console.WriteLine(\"            // [Focus] Mode Active: Only running focused tests.\");");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            var tasks = new global::System.Collections.Generic.List<global::System.Threading.Tasks.Task>();");
            sb.AppendLine("            ");
            sb.AppendLine("            // Bounded Parallelism (CRITICAL)");
            sb.AppendLine("            int? globalMax = activeTests.Select(t => t.MaxParallel).Where(m => m.HasValue).Min();");
            sb.AppendLine("            int maxParallel = globalMax ?? global::System.Environment.ProcessorCount;");
            sb.AppendLine("            using var semaphore = new global::System.Threading.SemaphoreSlim(maxParallel);");
            sb.AppendLine();
            sb.AppendLine("            foreach (var test in activeTests)");
            sb.AppendLine("            {");
            sb.AppendLine("                if (test.SkipReason != null)");
            sb.AppendLine("                {");
            sb.AppendLine("                    reporter.OnTestSkipped(test.DisplayName, test.SkipReason);");
            sb.AppendLine("                    global::System.Threading.Interlocked.Increment(ref skipped);");
            sb.AppendLine("                    continue;");
            sb.AppendLine("                }");
            sb.AppendLine();
            sb.AppendLine("                if (filters.Any() && !filters.All(f => test.Traits.Contains(f))) continue;");
            sb.AppendLine();
            sb.AppendLine("                await semaphore.WaitAsync();");
            sb.AppendLine("                tasks.Add(global::System.Threading.Tasks.Task.Run(async () => {");
            sb.AppendLine("                    try {");
            sb.AppendLine("                        if (await RunTestSafe(test.ExecuteDelegate, test.DisplayName, reporter, test.Description, test.RetryCount))");
            sb.AppendLine("                            global::System.Threading.Interlocked.Increment(ref passed);");
            sb.AppendLine("                        else");
            sb.AppendLine("                            global::System.Threading.Interlocked.Increment(ref failed);");
            sb.AppendLine("                    } finally {");
            sb.AppendLine("                        semaphore.Release();");
            sb.AppendLine("                    }");
            sb.AppendLine("                }));");
            sb.AppendLine("            }");
            sb.AppendLine("            await global::System.Threading.Tasks.Task.WhenAll(tasks);");
            sb.AppendLine();
            sb.AppendLine("            sw.Stop();");
            sb.AppendLine("            reporter.OnComplete(passed, failed, skipped, sw.Elapsed);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets the list of available tests.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static global::System.Collections.Generic.IEnumerable<ProvaTest> GetTests()");
            sb.AppendLine("        {");
            sb.AppendLine("            var list = new global::System.Collections.Generic.List<ProvaTest>();");

            var allMethods = methods.Where(m => m != null).ToList();
            var groupedMethods = allMethods.GroupBy(m => m!.ClassName);

            foreach (var group in groupedMethods)
            {
                var className = group.Key;
                var classFixtures = group.First()!.FixtureTypes;
                sb.AppendLine($"            // Class: {className}");
                
                foreach (var method in group)
                {
                    if (method == null) continue;

                    if (method.IsTheory)
                    {
                        int theoryIndex = 0;
                        if (method.TestData.Count > 0)
                        {
                            foreach (var args in method.TestData)
                            {
                                var argsString = string.Join(", ", args);
                                GenerateTestRegistration(sb, method, argsString, $"({argsString})", classFixtures); // Static args in name
                            }
                        }


                        
                        if (method.ClassData.Count > 0)
                        {
                            foreach (var cdType in method.ClassData)
                            {
                                sb.AppendLine($"            // ClassData: {cdType}");
                                sb.AppendLine($"            var classData_{theoryIndex} = new {cdType}();");
                                sb.AppendLine($"            foreach (var dataRow in classData_{theoryIndex})");
                                sb.AppendLine("            {");
                                sb.AppendLine("                {");
                                var castArgs = new List<string>();
                                for(int i = 0; i < method.ParameterTypes.Count; i++)
                                {
                                    castArgs.Add($"({method.ParameterTypes[i]})dataRow[{i}]");
                                }
                                GenerateTestRegistration(sb, method, string.Join(", ", castArgs), $"({{string.Join(\", \", dataRow)}})", classFixtures); // Dynamic args in name
                                sb.AppendLine("                }");
                                sb.AppendLine("            }");
                            }
                        }

                        if (method.MemberData.Count > 0)
                        {
                            foreach (var md in method.MemberData)
                            {
                                var targetType = md.MemberType ?? method.ClassName; 
                                var invoke = $"{targetType}.{md.MemberName}";
                                string access = md.Parameters.Length > 0 
                                    ? $"{invoke}({string.Join(", ", md.Parameters)})" 
                                    : (md.IsMethod ? $"{invoke}()" : $"{invoke}");

                                sb.AppendLine($"            // MemberData: {md.MemberName}");
                                sb.AppendLine($"            foreach (var dataRow in {access})");
                                sb.AppendLine("            {");
                                sb.AppendLine("                {");
                                var castArgs = new List<string>();
                                for(int i = 0; i < method.ParameterTypes.Count; i++)
                                {
                                    castArgs.Add($"({method.ParameterTypes[i]})dataRow[{i}]");
                                }
                                GenerateTestRegistration(sb, method, string.Join(", ", castArgs), $"({{string.Join(\", \", dataRow)}})", classFixtures); // Dynamic args in name
                                sb.AppendLine("                }");
                                sb.AppendLine("            }");
                            }
                        }
                    }
                    else
                    {
                        GenerateTestRegistration(sb, method, "", "", classFixtures);
                    }
                }
            }

            sb.AppendLine("            return list;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        private static async global::System.Threading.Tasks.Task<bool> RunTestSafe(global::System.Func<global::System.Threading.Tasks.Task<string?>> test, string name, ITestReporter reporter, string? description = null, int retryCount = 0)");
            sb.AppendLine("        {");
            sb.AppendLine("             reporter.OnTestStarting(name, description);");
            sb.AppendLine("             int attempt = 0;");
            sb.AppendLine("             while (true)");
            sb.AppendLine("             {");
            sb.AppendLine("                 try {");
            sb.AppendLine("                     var output = await test();");
            sb.AppendLine("                     reporter.OnTestSuccess(name, output ?? \"\");");
            sb.AppendLine("                     return true;");
            sb.AppendLine("                 } catch (global::System.Exception ex) {");
            sb.AppendLine("                     attempt++;");
            sb.AppendLine("                     if (attempt <= retryCount) continue;");
            sb.AppendLine("                     // In case of failure, we might not get output if it failed before return.");
            sb.AppendLine("                     // But usually output is captured in the delegate wrapper anyway for failures?");
            sb.AppendLine("                     // Actually, if exception is thrown, we don't return.");
            sb.AppendLine("                     // We need to ensure output is captured even on exception.");
            sb.AppendLine("                     // But for now let's pass empty string on failure as simpler v1, ");
            sb.AppendLine("                     // or we rely on the fact that if it throws we can't easily get the local var.");
            sb.AppendLine("                     // Unless we wrapped it in try-finally inside the delegate. ");
            sb.AppendLine("                     // Let's assume empty output for now on exception to keep it simple, ");
            sb.AppendLine("                     // or the user can fix the code to not crash :)");
            sb.AppendLine("                     // Actually in the generated code we can wrap user code in try/catch and rethrow?");
            sb.AppendLine("                     // Let's stick to simple first.");
            sb.AppendLine("                     reporter.OnTestFailure(name, ex, \"\"); ");
            sb.AppendLine("                     return false;");
            sb.AppendLine("                 }");
            sb.AppendLine("             }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            context.AddSource("TestRunnerExecutor.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static void GenerateTestRegistration(StringBuilder sb, TestMethodModel method, string args, string displayNameSuffixExpression, List<string> classFixtures)
        {
             sb.AppendLine($"            list.Add(new ProvaTest");
             sb.AppendLine($"            {{");
             sb.AppendLine($"                DisplayName = $\"{method.ClassName}.{method.MethodName}{displayNameSuffixExpression}\",");
             sb.AppendLine($"                Description = {(method.Description == null ? "null" : $"\"{method.Description}\"")},");
             sb.AppendLine($"                SkipReason = {(method.SkipReason == null ? "null" : $"\"{method.SkipReason}\"")},");
             sb.AppendLine($"                RetryCount = {method.RetryCount},");
             sb.AppendLine($"                MaxParallel = {(method.MaxParallel == null ? "null" : method.MaxParallel.Value.ToString(global::System.Globalization.CultureInfo.InvariantCulture))},");
             
             if (method.Traits.Count == 0 && !method.IsFocused)
             {
                 sb.AppendLine("                Traits = global::System.Array.Empty<global::System.Collections.Generic.KeyValuePair<string, string>>(),");
             }
             else
             {
                 var traits = method.Traits.Select(t => $"new global::System.Collections.Generic.KeyValuePair<string, string>(\"{t.Key}\", \"{t.Value}\")").ToList();
                 if (method.IsFocused) traits.Add("new global::System.Collections.Generic.KeyValuePair<string, string>(\"Focus\", \"true\")");
                 sb.AppendLine($"                Traits = new[] {{ {string.Join(", ", traits)} }},");
             }

             sb.AppendLine($"                ExecuteDelegate = async () => ");
             sb.AppendLine($"                {{");
             if (method.UsesOutputHelper) sb.AppendLine($"                    var outputHelper = new TestOutputHelper();");

             foreach (var fixtureType in classFixtures)
             {
                 var varName = $"fixture_{fixtureType.Replace(".", "_")}";
                 sb.AppendLine($"                    var {varName} = new {fixtureType}();");
                 sb.AppendLine($"                    if ({varName} is IAsyncLifetime al_init_{varName}) await al_init_{varName}.InitializeAsync();");
             }

             if (!method.IsStatic)
             {
                 sb.AppendLine($"                    var instance = new {method.ClassName}({string.Join(", ", method.Dependencies)});");
                 if (method.ImplementsAsyncLifetime) sb.AppendLine($"                    if (instance is IAsyncLifetime asyncLifeInit) await asyncLifeInit.InitializeAsync();");
             }

             sb.AppendLine("                    try {");
             sb.AppendLine($"                        long? maxAlloc = {(method.MaxAllocBytes.HasValue ? method.MaxAllocBytes.Value.ToString(global::System.Globalization.CultureInfo.InvariantCulture) : "null")};");
             sb.AppendLine("                        long startAlloc = 0;");
             sb.AppendLine("                        if (maxAlloc.HasValue) startAlloc = global::System.GC.GetAllocatedBytesForCurrentThread();");

             string target = method.IsStatic ? method.ClassName : "instance";
             string invocation = method.IsAsync ? $"await {target}.{method.MethodName}({args})" : $"{target}.{method.MethodName}({args})";

             // Timeout Logic ‚è±Ô∏è
             if (method.TimeoutMs.HasValue)
             {
                 sb.AppendLine($"                        var testTask = global::System.Threading.Tasks.Task.Run(async () => {{ {invocation}; }});");
                 sb.AppendLine($"                        var timeoutTask = global::System.Threading.Tasks.Task.Delay({method.TimeoutMs.Value});");
                 sb.AppendLine("                        var completedTask = await global::System.Threading.Tasks.Task.WhenAny(testTask, timeoutTask);");
                 sb.AppendLine("                        if (completedTask == timeoutTask)");
                 sb.AppendLine($"                            throw new global::System.TimeoutException(\"Test exceeded timeout of {method.TimeoutMs.Value}ms.\");");
                 sb.AppendLine("                        await testTask; // Propagate exceptions");
             }
             else
             {
                 sb.AppendLine($"                        {invocation};");
             }
             
             sb.AppendLine("                        if (maxAlloc.HasValue)");
             sb.AppendLine("                        {");
             sb.AppendLine("                            long totalAlloc = global::System.GC.GetAllocatedBytesForCurrentThread() - startAlloc;");
             sb.AppendLine("                            if (totalAlloc > maxAlloc.Value)");
             sb.AppendLine("                                throw new global::System.Exception($\"Test exceeded allocation budget! Allowed: {maxAlloc.Value} bytes. Allocated: {totalAlloc} bytes.\");");
             sb.AppendLine("                        }");

             if (!method.IsStatic && method.MockFields.Count > 0)
             {
                 sb.AppendLine("                        // Nordic Suite: Smart Verify üõ°Ô∏è");
                 foreach (var mockName in method.MockFields) sb.AppendLine($"                        instance.{mockName}.VerifyAll();");
             }

             sb.AppendLine("                    } finally {");
             if (!method.IsStatic)
             {
                 if (method.ImplementsAsyncLifetime) sb.AppendLine($"                        if (instance is IAsyncLifetime asyncLifeDisp) await asyncLifeDisp.DisposeAsync();");
                 sb.AppendLine($"                        if (instance is global::System.IDisposable d) d.Dispose();");
             }
             foreach (var fixtureType in classFixtures)
             {
                 var varName = $"fixture_{fixtureType.Replace(".", "_")}";
                 sb.AppendLine($"                    if ({varName} is IAsyncLifetime al_{varName}) await al_{varName}.DisposeAsync();");
                 sb.AppendLine($"                    else if ({varName} is global::System.IDisposable d_{varName}) d_{varName}.Dispose();");
             }

             sb.AppendLine("                    }");
             sb.AppendLine($"                    return {(method.UsesOutputHelper ? "outputHelper.Output" : "null")};");
             sb.AppendLine("                }");
             sb.AppendLine("            });");
        }
    }
}
