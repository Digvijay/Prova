using System;
using Xunit;

namespace Prova.Generators.Tests
{
    public class DiscoveryTests
    {
        [Fact]
        public void Fact_Discovers_Test()
        {
            var source = @"
using Prova;
using System;

public class MyFactTests
{
    [Fact]
    public void SimpleFact()
    {
    }
}";
            // Expected partial match for the standard runner
            var expectedSnippet = @"            // Class: MyFactTests
            list.Add(new ProvaTest
            {
                DisplayName = $""MyFactTests.SimpleFact"",
                Description = null,
                SkipReason = null,
                RetryCount = 0,
                MaxParallel = null,
                Traits = global::System.Array.Empty<global::System.Collections.Generic.KeyValuePair<string, string>>(),
                ExecuteDelegate = async () => 
                {
                    var instance = new MyFactTests();
                    try {
                        long? maxAlloc = null;
                        long startAlloc = 0;
                        if (maxAlloc.HasValue) startAlloc = global::System.GC.GetAllocatedBytesForCurrentThread();
                        instance.SimpleFact();
                        if (maxAlloc.HasValue)
                        {
                            long totalAlloc = global::System.GC.GetAllocatedBytesForCurrentThread() - startAlloc;
                            if (totalAlloc > maxAlloc.Value)
                                throw new global::System.Exception($""Test exceeded allocation budget! Allowed: {maxAlloc.Value} bytes. Allocated: {totalAlloc} bytes."");
                        }
                    } finally {
                        if (instance is global::System.IDisposable d) d.Dispose();
                    }
                    return null;
                }
            });";

            // We verify by checking if the expected snippet is contained in the generated source
            // Or we can do full match. Ideally full match for rigor.
            // Let's rely on full snapshot calibration again.
             var expected = @"// <auto-generated/>
#nullable enable
using System;
using System.Threading.Tasks;
using System.Threading;
using System.Linq;
using System.Collections.Generic;
using Prova;
using Prova.Reporters;
using Microsoft.Testing.Extensions;

namespace Prova.Generated
{
    /// <summary>
    /// Executor for running tests.
    /// </summary>
    public static class TestRunnerExecutor
    {
        /// <summary>
        /// Runs all tests.
        /// </summary>
        /// <param name=""args"">The command line arguments.</param>
        public static async global::System.Threading.Tasks.Task RunAllAsync(string[]? args = null)
        {
            args ??= global::System.Array.Empty<string>();
            bool isMtp = args.Any(a => a == ""--list-tests"" || a == ""--server"" || a.StartsWith(""--client-port"") || a == ""--report-trx"" || a == ""--coverage"" || a == ""--help"" || a == ""-?"" || a == ""-h"");
            bool isSimple = args.Contains(""--simple"");

            if (isMtp && !isSimple)
            {
                await RunMtpAsync(args);
            }
            else
            {
                await RunSimpleAsync(args);
            }
        }

        private static async global::System.Threading.Tasks.Task RunMtpAsync(string[] args)
        {
            var builder = await global::Microsoft.Testing.Platform.Builder.TestApplication.CreateBuilderAsync(args);
            builder.AddTrxReportProvider();
            builder.AddCodeCoverageProvider();
            builder.RegisterTestFramework(
                _ => new ProvaCapabilities(),
                (cap, _) => new HybridMtpAdapter(GetTests(), cap));
            using var app = await builder.BuildAsync();
            await app.RunAsync();
        }

        private static async global::System.Threading.Tasks.Task RunSimpleAsync(string[] args)
        {
            var reporter = new ConsoleReporter();
            int passed = 0, failed = 0, skipped = 0;
            var sw = global::System.Diagnostics.Stopwatch.StartNew();

            var filters = new global::System.Collections.Generic.List<global::System.Collections.Generic.KeyValuePair<string, string>>();
            for (int i = 0; i < args.Length; i++)
            {
                if (args[i] == ""--filter"" && i + 1 < args.Length)
                {
                    var parts = args[i+1].Split('=');
                    if (parts.Length == 2) filters.Add(new global::System.Collections.Generic.KeyValuePair<string, string>(parts[0], parts[1]));
                }
            }

            var tests = GetTests();
            var hasFocus = tests.Any(t => t.Traits.Any(tr => tr.Key == ""Focus""));
            var activeTests = hasFocus 
                ? tests.Where(t => t.Traits.Any(tr => tr.Key == ""Focus"")).ToList() 
                : tests.ToList();

            if (hasFocus)
            {
                 global::System.Console.WriteLine(""            // [Focus] Mode Active: Only running focused tests."");
            }

            var tasks = new global::System.Collections.Generic.List<global::System.Threading.Tasks.Task>();
            
            // Bounded Parallelism (CRITICAL)
            int? globalMax = activeTests.Select(t => t.MaxParallel).Where(m => m.HasValue).Min();
            int maxParallel = globalMax ?? global::System.Environment.ProcessorCount;
            using var semaphore = new global::System.Threading.SemaphoreSlim(maxParallel);

            foreach (var test in activeTests)
            {
                if (test.SkipReason != null)
                {
                    reporter.OnTestSkipped(test.DisplayName, test.SkipReason);
                    global::System.Threading.Interlocked.Increment(ref skipped);
                    continue;
                }

                if (filters.Any() && !filters.All(f => test.Traits.Contains(f))) continue;

                await semaphore.WaitAsync();
                tasks.Add(global::System.Threading.Tasks.Task.Run(async () => {
                    try {
                        if (await RunTestSafe(test.ExecuteDelegate, test.DisplayName, reporter, test.Description, test.RetryCount))
                            global::System.Threading.Interlocked.Increment(ref passed);
                        else
                            global::System.Threading.Interlocked.Increment(ref failed);
                    } finally {
                        semaphore.Release();
                    }
                }));
            }
            await global::System.Threading.Tasks.Task.WhenAll(tasks);

            sw.Stop();
            reporter.OnComplete(passed, failed, skipped, sw.Elapsed);
        }

        /// <summary>
        /// Gets the list of available tests.
        /// </summary>
        public static global::System.Collections.Generic.IEnumerable<ProvaTest> GetTests()
        {
            var list = new global::System.Collections.Generic.List<ProvaTest>();
            // Class: MyFactTests
            list.Add(new ProvaTest
            {
                DisplayName = $""MyFactTests.SimpleFact"",
                Description = null,
                SkipReason = null,
                RetryCount = 0,
                MaxParallel = null,
                Traits = global::System.Array.Empty<global::System.Collections.Generic.KeyValuePair<string, string>>(),
                ExecuteDelegate = async () => 
                {
                    var instance = new MyFactTests();
                    try {
                        long? maxAlloc = null;
                        long startAlloc = 0;
                        if (maxAlloc.HasValue) startAlloc = global::System.GC.GetAllocatedBytesForCurrentThread();
                        instance.SimpleFact();
                        if (maxAlloc.HasValue)
                        {
                            long totalAlloc = global::System.GC.GetAllocatedBytesForCurrentThread() - startAlloc;
                            if (totalAlloc > maxAlloc.Value)
                                throw new global::System.Exception($""Test exceeded allocation budget! Allowed: {maxAlloc.Value} bytes. Allocated: {totalAlloc} bytes."");
                        }
                    } finally {
                        if (instance is global::System.IDisposable d) d.Dispose();
                    }
                    return null;
                }
            });
            return list;
        }

        private static async global::System.Threading.Tasks.Task<bool> RunTestSafe(global::System.Func<global::System.Threading.Tasks.Task<string?>> test, string name, ITestReporter reporter, string? description = null, int retryCount = 0)
        {
             reporter.OnTestStarting(name, description);
             int attempt = 0;
             while (true)
             {
                 try {
                     var output = await test();
                     reporter.OnTestSuccess(name, output ?? """");
                     return true;
                 } catch (global::System.Exception ex) {
                     attempt++;
                     if (attempt <= retryCount) continue;
                     // In case of failure, we might not get output if it failed before return.
                     // But usually output is captured in the delegate wrapper anyway for failures?
                     // Actually, if exception is thrown, we don't return.
                     // We need to ensure output is captured even on exception.
                     // But for now let's pass empty string on failure as simpler v1, 
                     // or we rely on the fact that if it throws we can't easily get the local var.
                     // Unless we wrapped it in try-finally inside the delegate. 
                     // Let's assume empty output for now on exception to keep it simple, 
                     // or the user can fix the code to not crash :)
                     // Actually in the generated code we can wrap user code in try/catch and rethrow?
                     // Let's stick to simple first.
                     reporter.OnTestFailure(name, ex, """"); 
                     return false;
                 }
             }
        }
    }
}";
            GeneratorVerifier.Verify(source, expected);
        }
    }
}
