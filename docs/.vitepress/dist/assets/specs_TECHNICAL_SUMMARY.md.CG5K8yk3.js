import{_ as i,o as e,c as a,ae as t}from"./chunks/framework.BD9pLfSD.js";const c=JSON.parse('{"title":"Prova: Technical Summary (Deep Dive)","description":"","frontmatter":{},"headers":[],"relativePath":"specs/TECHNICAL_SUMMARY.md","filePath":"specs/TECHNICAL_SUMMARY.md"}'),n={name:"specs/TECHNICAL_SUMMARY.md"};function l(r,s,o,h,p,k){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="prova-technical-summary-deep-dive" tabindex="-1">Prova: Technical Summary (Deep Dive) <a class="header-anchor" href="#prova-technical-summary-deep-dive" aria-label="Permalink to &quot;Prova: Technical Summary (Deep Dive)&quot;">​</a></h1><p><strong>Target Audience:</strong> Architects, Framework Authors, Performance Engineers.</p><blockquote><p><strong>Project Scope</strong>: Prova is a standalone <strong>reference implementation</strong> and an <strong>experimental research project</strong>. It is intended to showcase the potential of Roslyn-based testing architectures. It is not associated with Microsoft Corporation but provides a <strong>Hybrid MTP Adapter</strong> for compatibility with the modern .NET testing ecosystem.</p></blockquote><h2 id="core-philosophy-compile-time-is-the-new-runtime" tabindex="-1">Core Philosophy: &quot;Compile-Time is the new Runtime&quot; <a class="header-anchor" href="#core-philosophy-compile-time-is-the-new-runtime" aria-label="Permalink to &quot;Core Philosophy: &quot;Compile-Time is the new Runtime&quot;&quot;">​</a></h2><p>Prova is a fundamental rethink of .NET testing infrastructure, moving the heavy lifting of test discovery and orchestration from <strong>Runtime Reflection</strong> to <strong>Roslyn Source Generators</strong>.</p><h3 id="_1-the-source-generator-architecture" tabindex="-1">1. The Source Generator Architecture <a class="header-anchor" href="#_1-the-source-generator-architecture" aria-label="Permalink to &quot;1. The Source Generator Architecture&quot;">​</a></h3><p>Instead of <code>Assembly.GetTypes().SelectMany(t =&gt; t.GetMethods())...</code> at runtime, Prova employs an <code>IIncrementalGenerator</code> pipeline:</p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// High-Level Pipeline</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testMethods</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context.SyntaxProvider</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CreateSyntaxProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        predicate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IsCandidate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ModelFactory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Expensive semantic analysis</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RegisterSourceOutput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(testMethods, (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">methods</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Generates a Single Static Entry Point</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SourceEmitter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(spc, methods);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p><strong>Key Advantages:</strong></p><ul><li><strong>Zero-Cost Abstractions</strong>: Attributes like <code>[Fact]</code> and <code>[Trait]</code> are peeled away at compile time. The resulting code is just raw <code>Task</code> invocation.</li><li><strong>Tree Shaking / Trimming</strong>: Since test calls are static references (<code>MethodA()</code>), the IL linker (ILLink) knows exactly what is used. Unused code is aggressively trimmed.</li><li><strong>Diagnostics</strong>: Invalid test signatures (e.g., <code>void</code> instead of <code>Task</code> for async) are caught as <strong>Compiler Errors</strong> (or Analyzer warnings), not runtime failures.</li></ul><h3 id="_2-native-aot-compatibility" tabindex="-1">2. Native AOT Compatibility <a class="header-anchor" href="#_2-native-aot-compatibility" aria-label="Permalink to &quot;2. Native AOT Compatibility&quot;">​</a></h3><p>Traditional frameworks (xUnit, NUnit, MSTest) rely on:</p><ul><li><code>System.Reflection.Emit</code> (Dynamic Proxies)</li><li><code>RuntimeHelpers.RunClassConstructor</code></li><li>Extensive use of <code>MakeGenericType</code></li></ul><p>This makes AOT challenging (requiring massive <code>rd.xml</code> directives).</p><p><strong>Prova is AOT-Native by default.</strong></p><ul><li>No dynamic code generation.</li><li>No <code>Type.MakeGenericType</code> at runtime (handled by generating generic instantiations at compile time).</li><li>No Reflection scanning.</li></ul><h3 id="_3-concurrency-model-task-whenall" tabindex="-1">3. Concurrency Model: <code>Task.WhenAll</code> <a class="header-anchor" href="#_3-concurrency-model-task-whenall" aria-label="Permalink to &quot;3. Concurrency Model: \`Task.WhenAll\`&quot;">​</a></h3><p>Prova treats the test suite as a massive async graph.</p><p><strong>Generated Code Structure:</strong></p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Task</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RunAllAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tasks</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Bounded Schedular implemented via SemaphoreSlim(maxParallel)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> semaphore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SemaphoreSlim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(maxParallel);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    foreach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tests)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> semaphore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WaitAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        tasks.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Task.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // Output is bubbled up from the test logic</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                 string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">? </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">output</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ExecuteDelegate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                 reporter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OnSuccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(test, output);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                 semaphore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Task.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WhenAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tasks);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This maximizes thread pool utilization while preventing starvation via the <code>[Parallel(max: n)]</code> setting.</p><h3 id="_4-zero-allocation-testing-goals" tabindex="-1">4. Zero-Allocation Testing Goals <a class="header-anchor" href="#_4-zero-allocation-testing-goals" aria-label="Permalink to &quot;4. Zero-Allocation Testing Goals&quot;">​</a></h3><p>We minimize heap allocations in the runner loop:</p><ul><li><strong>Reuse</strong>: The <code>ConsoleReporter</code> uses <code>Interlocked</code> counters rather than locking heavy objects.</li><li><strong>Structs</strong>: Internal models used during execution are kept lean.</li><li><strong>No Boxing</strong>: <code>Assert</code> methods use generic constraints (<code>T</code>) to avoid boxing value types where possible.</li></ul><h3 id="_5-compiler-integrated-features" tabindex="-1">5. Compiler-Integrated Features <a class="header-anchor" href="#_5-compiler-integrated-features" aria-label="Permalink to &quot;5. Compiler-Integrated Features&quot;">​</a></h3><p>Because we control the compilation:</p><ul><li><strong><code>[Focus]</code></strong>: We filter the test execution set at the entry point. When <code>[Focus]</code> is active, only the targeted tests are added to the execution graph, ensuring zero distractions and immediate feedback.</li><li><strong>Documentation</strong>: We read the <code>SyntaxTree</code> XML trivia (<code>/// &lt;summary&gt;</code>) at compile-time and bake it directly into the runner. No XML parsing or reflection occurs at runtime.</li></ul><h3 id="_6-concurrency-boundedness" tabindex="-1">6. Concurrency Boundedness <a class="header-anchor" href="#_6-concurrency-boundedness" aria-label="Permalink to &quot;6. Concurrency Boundedness&quot;">​</a></h3><p>Prova implements a <strong>Bounded Scheduler</strong> via <code>SemaphoreSlim</code> in both the Console Runner and the MTP Adapter.</p><ul><li><strong>Default</strong>: <code>Environment.ProcessorCount</code>.</li><li><strong>Override</strong>: Use <code>[Parallel(max: n)]</code> at the class level to specify a custom limit. Prova takes the minimum <code>max</code> found across all tests to ensure the most restrictive environment is honored.</li></ul><h3 id="_7-output-capture" tabindex="-1">7. Output Capture <a class="header-anchor" href="#_7-output-capture" aria-label="Permalink to &quot;7. Output Capture&quot;">​</a></h3><p>Capturing stdout in parallel/async tests is difficult. <code>Console.SetOut</code> is not thread-safe. Prova solves this by injecting a per-test <code>ITestOutputHelper</code>.</p><ul><li>The generator creates a new <code>TestOutputHelper</code> instance for each test.</li><li>The <code>ExecuteDelegate</code> signature is modified from <code>Func&lt;Task&gt;</code> to <code>Func&lt;Task&lt;string?&gt;&gt;</code>.</li><li>Logs are strictly isolated and returned to the runner <em>after</em> execution, ensuring no cross-talk between thread logs.</li></ul><h3 id="_8-aot-dependency-injection-factory-pattern" tabindex="-1">8. AOT Dependency Injection (Factory Pattern) <a class="header-anchor" href="#_8-aot-dependency-injection-factory-pattern" aria-label="Permalink to &quot;8. AOT Dependency Injection (Factory Pattern)&quot;">​</a></h3><p>To avoid runtime reflection (scanning constructors), Prova uses an <strong>Explicit Factory Pattern</strong>:</p><ul><li><strong>Setup</strong>: Users mark static factory methods with <code>[TestDependency]</code>.</li><li><strong>Index</strong>: The analyzer builds a <code>ReturnType -&gt; MethodCall</code> map at compile time.</li><li><strong>Wiring</strong>: When generating test instantiation (<code>new MyTest(dep)</code>), the emitter resolves dependencies from this map directly in source code.</li><li><strong>Result</strong>: Zero DI container overhead. Zero runtime resolution. 100% Native AOT safe.</li></ul><h3 id="_9-governance-prophetic-allocation-monitoring" tabindex="-1">9. Governance: Prophetic Allocation Monitoring <a class="header-anchor" href="#_9-governance-prophetic-allocation-monitoring" aria-label="Permalink to &quot;9. Governance: Prophetic Allocation Monitoring&quot;">​</a></h3><p>To enforce <code>[MaxAlloc(n)]</code>, Prova does <strong>not</strong> use a profiler API or complex instrumentation.</p><ul><li><strong>Mechanism</strong>: The generator simply wraps the test call in a <code>try/finally</code> block.</li><li><strong>Measurement</strong>: <code>GC.GetAllocatedBytesForCurrentThread()</code> is called before and after the test delegate.</li><li><strong>Cost</strong>: If <code>[MaxAlloc]</code> is missing, <strong>0 instructions</strong> are emitted. The overhead is strictly pay-for-play.</li><li><strong>Safety</strong>: Because this happens inside the <code>Task.Run</code> delegate, it correctly attributes allocations to the specific test thread (even in parallel execution).</li></ul><h3 id="summary-for-infrastructure-teams" tabindex="-1">Summary for Infrastructure Teams <a class="header-anchor" href="#summary-for-infrastructure-teams" aria-label="Permalink to &quot;Summary for Infrastructure Teams&quot;">​</a></h3><p>Prova is designed to be embedded in high-performance CI/CD pipelines where:</p><ul><li><strong>Startup time matters</strong> (Micro-benchmarking, rapid inner loop).</li><li><strong>Binary size matters</strong> (WASM, Mobile, IoT scenarios).</li><li><strong>Stability matters</strong> (Compiler-verified test definitions).</li></ul><p>It is not just a test framework; it is a <strong>Static Analysis Tool</strong> that happens to run tests.</p>`,43)])])}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
