import{_ as t,o,c as a,ae as i}from"./chunks/framework.BD9pLfSD.js";const d=JSON.parse('{"title":"Executive Summary: Prova","description":"","frontmatter":{},"headers":[],"relativePath":"specs/EXECUTIVE_SUMMARY.md","filePath":"specs/EXECUTIVE_SUMMARY.md"}'),r={name:"specs/EXECUTIVE_SUMMARY.md"};function n(s,e,c,l,p,m){return o(),a("div",null,[...e[0]||(e[0]=[i('<h1 id="executive-summary-prova" tabindex="-1">Executive Summary: Prova <a class="header-anchor" href="#executive-summary-prova" aria-label="Permalink to &quot;Executive Summary: Prova&quot;">​</a></h1><p><em>Reference Implementation for Native AOT Testing</em></p><blockquote><p><strong>Project Scope</strong>: Prova is a standalone <strong>reference implementation</strong> and an <strong>experimental research project</strong>. It showcases the potential of Roslyn-based testing architectures. It is a research initiative and is not associated with Microsoft Corporation.</p></blockquote><h2 id="project-objectives" tabindex="-1">Project Objectives <a class="header-anchor" href="#project-objectives" aria-label="Permalink to &quot;Project Objectives&quot;">​</a></h2><p><strong>Prova</strong> demonstrates the capabilities of the modern .NET ecosystem, specifically leveraging <strong>Roslyn Source Generators</strong> to shift test discovery and orchestration from <strong>Runtime Reflection</strong> to <strong>Compile Time</strong>.</p><h2 id="key-architectural-principles" tabindex="-1">Key Architectural Principles <a class="header-anchor" href="#key-architectural-principles" aria-label="Permalink to &quot;Key Architectural Principles&quot;">​</a></h2><h3 id="_1-compile-time-generation" tabindex="-1">1. Compile-Time Generation <a class="header-anchor" href="#_1-compile-time-generation" aria-label="Permalink to &quot;1. Compile-Time Generation&quot;">​</a></h3><p>Legacy frameworks rely on runtime reflection for discovery, which incurs startup costs and limits optimization. Prova generates the test runner harnessing code during compilation.</p><ul><li><strong>Legacy</strong>: Runtime Assembly Scanning -&gt; Type Reflection -&gt; Dynamic Invocation.</li><li><strong>Prova</strong>: Source Generation -&gt; Static Linking -&gt; Direct Execution.</li></ul><h3 id="_2-enhanced-developer-experience" tabindex="-1">2. Enhanced Developer Experience <a class="header-anchor" href="#_2-enhanced-developer-experience" aria-label="Permalink to &quot;2. Enhanced Developer Experience&quot;">​</a></h3><p>Leveraging compiler access allows for features that are difficult to implement in runtime-only frameworks:</p><ul><li><strong>Documentation Integration</strong>: XML documentation comments (<code>/// &lt;summary&gt;</code>) are extracted at compile-time and included in test reports.</li><li><strong>Selective Compilation</strong>: The <code>[Focus]</code> attribute instructs the generator to emit code only for the target test, significantly reducing the debug loop.</li></ul><h3 id="_3-native-aot-compatibility" tabindex="-1">3. Native AOT Compatibility <a class="header-anchor" href="#_3-native-aot-compatibility" aria-label="Permalink to &quot;3. Native AOT Compatibility&quot;">​</a></h3><p>Prova is designed for <strong>Native AOT</strong>. Test suites can be compiled into standalone, optimized binaries that operate without a full .NET runtime dependency, ideal for containerized or constrained environments.</p><h2 id="integration" tabindex="-1">Integration <a class="header-anchor" href="#integration" aria-label="Permalink to &quot;Integration&quot;">​</a></h2><p>Prova serves as a reference for integrating with other AOT-compatible tools, such as <strong>Skugga</strong> (AOT Mocks). It demonstrates patterns for compile-time heuristic detection of dependencies to reduce boilerplate without runtime coupling.</p><h2 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to &quot;Conclusion&quot;">​</a></h2><p>Prova provides a blueprint for high-performance, AOT-safe testing infrastructures. It serves as a proof-of-concept for framework authors looking to modernize their architecture using strict static analysis and source generation.</p>',18)])])}const h=t(r,[["render",n]]);export{d as __pageData,h as default};
