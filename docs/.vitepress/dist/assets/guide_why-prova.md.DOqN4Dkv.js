import{_ as e,o as a,c as i,ae as s}from"./chunks/framework.BD9pLfSD.js";const u=JSON.parse('{"title":"Why Prova?","description":"","frontmatter":{},"headers":[],"relativePath":"guide/why-prova.md","filePath":"guide/why-prova.md"}'),n={name:"guide/why-prova.md"};function r(o,t,l,h,d,p){return a(),i("div",null,[...t[0]||(t[0]=[s('<h1 id="why-prova" tabindex="-1">Why Prova? <a class="header-anchor" href="#why-prova" aria-label="Permalink to &quot;Why Prova?&quot;">​</a></h1><p>There are several great test runners for .NET. Here is why you might choose Prova.</p><h2 id="the-migration-first-philosophy" tabindex="-1">The &quot;Migration First&quot; Philosophy <a class="header-anchor" href="#the-migration-first-philosophy" aria-label="Permalink to &quot;The &quot;Migration First&quot; Philosophy&quot;">​</a></h2><p>If you are starting a <strong>greenfield</strong> project, you might choose TUnit for its modern fluent syntax. However, if you have <strong>5,000 existing tests</strong> written in xUnit, rewriting them to use <code>[Test]</code> and <code>Assert.That</code> is a massive cost.</p><p><strong>Prova fills this specific gap.</strong> It is designed to be a drop-in replacement for xUnit in AOT scenarios.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Feature</th><th style="text-align:left;">xUnit v2</th><th style="text-align:left;">TUnit</th><th style="text-align:left;">Prova</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>AOT Support</strong></td><td style="text-align:left;">❌</td><td style="text-align:left;">✅</td><td style="text-align:left;">✅</td></tr><tr><td style="text-align:left;"><strong>Syntax</strong></td><td style="text-align:left;">Standard</td><td style="text-align:left;">New (Fluent)</td><td style="text-align:left;">Standard (xUnit)</td></tr><tr><td style="text-align:left;"><strong>Migration Cost</strong></td><td style="text-align:left;">N/A</td><td style="text-align:left;">High (Rewrite)</td><td style="text-align:left;"><strong>Zero</strong></td></tr><tr><td style="text-align:left;"><strong>Discovery</strong></td><td style="text-align:left;">Runtime Reflection</td><td style="text-align:left;">Source Gen</td><td style="text-align:left;">Source Gen</td></tr></tbody></table><h2 id="performance-stability" tabindex="-1">Performance &amp; Stability <a class="header-anchor" href="#performance-stability" aria-label="Permalink to &quot;Performance &amp; Stability&quot;">​</a></h2><p>Prova implements a <strong>Bounded Scheduler</strong> using <code>SemaphoreSlim</code>. Unlike runners that spawn unbounded Tasks (risking CI memory crashes), Prova allows you to strictly limit concurrency:</p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assembly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Parallel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Max</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Never burn your CI runner again</span></span></code></pre></div><h2 id="the-architecture-quality" tabindex="-1">The Architecture Quality <a class="header-anchor" href="#the-architecture-quality" aria-label="Permalink to &quot;The Architecture Quality&quot;">​</a></h2><h3 id="prova-the-raw-metal-engine" tabindex="-1">Prova: The &quot;Raw Metal&quot; Engine <a class="header-anchor" href="#prova-the-raw-metal-engine" aria-label="Permalink to &quot;Prova: The &quot;Raw Metal&quot; Engine&quot;">​</a></h3><p>Prova is built like a high-performance game engine. It avoids containers and abstractions in favor of generating a single, massive static void Main().</p><p><strong>Pros:</strong> Speed. There is no &quot;Lookup,&quot; no &quot;Resolution,&quot; no &quot;Middleware.&quot; It is just a direct CPU Jump (<code>CALL</code>) to your test method.</p><p><strong>Code Quality:</strong> &quot;Systems Programming.&quot; It uses raw <code>SemaphoreSlim</code> and manual loops. It’s optimized for raw execution speed.</p><h3 id="tunit-the-abstracted-enterprise-engine" tabindex="-1">TUnit: The &quot;Abstracted Enterprise&quot; Engine <a class="header-anchor" href="#tunit-the-abstracted-enterprise-engine" aria-label="Permalink to &quot;TUnit: The &quot;Abstracted Enterprise&quot; Engine&quot;">​</a></h3><p>TUnit is built like a modern ASP.NET Core application, utilizing heavy Dependency Injection (DI) containers and middleware pipelines.</p><p><strong>Pros:</strong> Highly extensible (custom loggers, filters).</p><p><strong>Cons:</strong> Bloat. TUnit involves the &quot;Metadata Weight&quot; of a DI container, which can feel like running a small web server just to run unit tests.</p>',18)])])}const c=e(n,[["render",r]]);export{u as __pageData,c as default};
